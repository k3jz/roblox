local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Window = Library:CreateWindow({ Title = '                     $K3JZ$        ', AutoShow = true, TabPadding = 15, MenuFadeTime = 0.2 })
local Tabs = { Main = Window:AddTab('Main'), Character = Window:AddTab('Character'), Visuals = Window:AddTab('Visuals'), Misc = Window:AddTab('Misc'), Players = Window:AddTab('Players'), ['UI Settings'] = Window:AddTab('UI Settings') }
local GunMods = Tabs.Main:AddRightGroupbox('Gun Mods')
local KillAura = Tabs.Main:AddRightGroupbox('Combat')

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

local LocalPlayer = game:GetService('Players').LocalPlayer
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")


local lockedTarget = nil
local StickyAimEnabled = false
local HighlightEnabled = false
local TracerEnabled = false
local ViewTargetEnabled = false
local targetHitPart = "Head"
local targetToMouseTracer = true
local grabCheckEnabled = true
local koCheckEnabled = true
local friendCheckEnabled = false
local strafeEnabled = false
local strafeMode = "Orbit"
local strafeSpeed = 5
local strafeXOffset = 5
local predictMovementEnabled = false
local stompTargetEnabled = false
local lastPosition = nil
local oldPosition = nil
local Core = nil
local BodyVelocity = nil
local PredicTvalue = 1
local hiddenBulletsEnabled = false
local spectateStrafeEnabled = false
local AutoAmmoEnabled = false
local strafeWasEnabledBeforeAmmoBuy = false

local tracer = Drawing.new("Line")
tracer.Visible = false
tracer.Thickness = 1
tracer.Color = Color3.fromRGB(255, 255, 255)


function predictPosition(targetRoot, predictionMultiplier)
    if not targetRoot then return targetRoot.Position end
    if targetRoot.Velocity.Magnitude > 700 then
        return targetRoot.Position
    end
    return targetRoot.Position + (targetRoot.Velocity * predictionMultiplier)
end

local TargetingGroup = Tabs.Main:AddLeftGroupbox('Targeting')

TargetingGroup:AddToggle("StickyAim", {
    Text = "Sticky Aim",
    Default = false,
    Callback = function(Value)
        StickyAimEnabled = Value
        if not Value then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            targetHighlight.Enabled = false
            tracer.Visible = false
        end
    end
}):AddKeyPicker("StickyAimKeybind", {
    Default = "C",
    NoUI = false,
    Text = "Sticky Aim",
    Mode = "Toggle",
    Callback = function()
        if UserInputService:GetFocusedTextBox() then return end
        if lockedTarget then
            lockedTarget = nil
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
            targetHighlight.Enabled = false
            tracer.Visible = false
        else
            local camera = workspace.CurrentCamera
            local mouseLocation = UserInputService:GetMouseLocation()
            local closestTarget, closestDistance = nil, math.huge

            for _, otherPlayer in ipairs(Players:GetPlayers()) do
                if otherPlayer ~= LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild(targetHitPart) then
                    local bodyEffects = otherPlayer.Character:FindFirstChild("BodyEffects")
                    local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local isGrabbed = otherPlayer.Character:FindFirstChild("GRABBING_CONSTRAINT")

                    if (not grabCheckEnabled or not isGrabbed) and
                       (not friendCheckEnabled or not LocalPlayer:IsFriendsWith(otherPlayer.UserId)) then

                        local targetPart = otherPlayer.Character[targetHitPart]
                        local screenPosition, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - mouseLocation).Magnitude
                            if distance < closestDistance then
                                closestTarget = otherPlayer
                                closestDistance = distance
                            end
                        end
                    end
                end
            end

            if closestTarget then
                lockedTarget = closestTarget
            end
        end
    end
})

local Target = Tabs.Main:AddLeftGroupbox('Target')

maddieplsnomad = false

TargetingGroup:AddToggle("ViewTarget", {
    Text = "spectate",
    Default = false,
    Callback = function(Value)
        maddieplsnomad = Value
        if not Value then
            ViewTargetEnabled = false
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
}):AddKeyPicker("ViewTargetKeybind", {
    Default = "B",
    NoUI = false,
    Text = "spectate",
    Mode = "Toggle",
    Callback = function()
        if not maddieplsnomad or UserInputService:GetFocusedTextBox() then return end
        ViewTargetEnabled = not ViewTargetEnabled
        if ViewTargetEnabled and lockedTarget then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character
        else
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

TargetingGroup:AddDropdown("hp", {
    Text = "Hit Part",
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"},
    Default = "Head",
    Callback = function(Value)
        targetHitPart = Value
    end
})

Target:AddToggle("StrafeToggle", {
    Text = "Target Strafe",
    Default = false,
    Callback = function(Value)
        strafeEnabled = Value
        if not Value then
            if Core then
                Core:Destroy()
                Core = nil
            end
            if BodyVelocity then
                BodyVelocity:Destroy()
                BodyVelocity = nil
            end
            if oldPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = oldPosition
                oldPosition = nil
            end
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
}):AddKeyPicker("StrafeKeybind", {
    Default = "N",
    NoUI = false,
    Text = "Strafe",
    Mode = "Toggle",
    Callback = function()
        if UserInputService:GetFocusedTextBox() then return end
        strafeEnabled = not strafeEnabled
        if not strafeEnabled then
            if Core then
                Core:Destroy()
                Core = nil
            end
            if BodyVelocity then
                BodyVelocity:Destroy()
                BodyVelocity = nil
            end
            if oldPosition then
                LocalPlayer.Character.HumanoidRootPart.CFrame = oldPosition
                oldPosition = nil
            end
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

Target:AddToggle("SpectateStrafe", {
    Text = "Spectate Strafe",
    Default = false,
    Callback = function(Value)
        spectateStrafeEnabled = Value
        if not Value then
            workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChild("Humanoid")
        end
    end
})

Target:AddDropdown("StrafeMode", {
    Text = "Strafe Mode",
    Values = {"Orbit", "Random"},
    Default = "Orbit",
    Callback = function(Value)
        strafeMode = Value
    end
})

Target:AddSlider("StrafeSpeed", {
    Text = "Speed units",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        strafeSpeed = Value
    end
})

Target:AddSlider("StrafeXOffset", {
    Text = "z offset",
    Default = 5,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        strafeXOffset = Value
    end
})

Target:AddToggle("PredictMovement", {
    Text = "predict movement",
    Default = false,
    Callback = function(Value)
        predictMovementEnabled = Value
    end
})

Target:AddSlider("StrafePredictionDistance", {
    Text = "movement prediction",
    Default = 0.3,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        PredicTvalue = Value
    end
})

TargetingGroup:AddToggle("StompTarget", {
    Text = "Stomp Target",
    Default = false,
    Callback = function(Value)
        stompTargetEnabled = Value
    end
})

TargetingGroup:AddToggle("HiddenBullets", {
    Text = "invisible bullets",
    Default = false,
    Callback = function(Value)
        hiddenBulletsEnabled = Value
    end
})

TargetingGroup:AddToggle("AutoAmmo", {
    Text = "Auto Ammo",
    Default = false,
    Callback = function(Value)
        AutoAmmoEnabled = Value
    end
})

local function getCurrentGun()
    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool then
        return tool.Name
    end
    return nil
end

local function getAmmoCount(gunName)
    local inventory = LocalPlayer.DataFolder.Inventory
    local ammo = inventory:FindFirstChild(gunName)
    if ammo then
        return tonumber(ammo.Value) or 0
    end
    return 0
end

local function buyAmmo(gunName)
    local ShopFolder = Workspace:WaitForChild("Ignored"):WaitForChild("Shop")
    local AmmoMap = {
        ["[Revolver]"] = "12 [Revolver Ammo] - $55",
        ["[AUG]"] = "90 [AUG Ammo] - $87",
        ["[LMG]"] = "200 [LMG Ammo] - $328",
        ["[Rifle]"] = "5 [Rifle Ammo] - $273",
    }

    local ammoItemName = AmmoMap[gunName]
    if not ammoItemName then return end

    local ammoItem = ShopFolder:FindFirstChild(ammoItemName)
    if not ammoItem then return end

    local oldPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    local currentTool = LocalPlayer.Character:FindFirstChildOfClass("Tool")

    if currentTool then
        currentTool.Parent = LocalPlayer.Backpack
    end

    LocalPlayer.Character.HumanoidRootPart.CFrame = ammoItem.Head.CFrame * CFrame.new(0, 3.2, 0)

    local clickDetector = ammoItem:FindFirstChild("ClickDetector")
    if clickDetector then
        for i = 1, 5 do
            fireclickdetector(clickDetector)
            task.wait(0)
        end
    end

    if currentTool then
        currentTool.Parent = LocalPlayer.Character
    end

    LocalPlayer.Character.HumanoidRootPart.CFrame = oldPosition
end

local function checkAmmoAndBuy()
    if not AutoAmmoEnabled then return end

    local gunName = getCurrentGun()
    if not gunName then return end

    local ammoCount = getAmmoCount(gunName)
    if ammoCount <= 0 then
        strafeWasEnabledBeforeAmmoBuy = strafeEnabled
        strafeEnabled = false
        if Core then
            Core:Destroy()
            Core = nil
        end
        if BodyVelocity then
            BodyVelocity:Destroy()
            BodyVelocity = nil
        end

        buyAmmo(gunName)

        if strafeWasEnabledBeforeAmmoBuy then
            strafeEnabled = true
        end
    end
end

RunService.RenderStepped:Connect(function()
    checkAmmoAndBuy()

    if lockedTarget and lockedTarget.Character then
        local targetPart = lockedTarget.Character:FindFirstChild(targetHitPart)
        local bodyEffects = lockedTarget.Character:FindFirstChild("BodyEffects")
        local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
        local isGrabbed = lockedTarget.Character:FindFirstChild("GRABBING_CONSTRAINT")

        if ViewTargetEnabled then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character
        elseif spectateStrafeEnabled and strafeEnabled then
            workspace.CurrentCamera.CameraSubject = lockedTarget.Character:FindFirstChild("Head")
        end

        if strafeEnabled and targetPart and not isGrabbed then
            local targetRoot = lockedTarget.Character:FindFirstChild("HumanoidRootPart")
            local targetPosition = targetRoot.Position

            if predictMovementEnabled then
                targetPosition = predictPosition(targetRoot, PredicTvalue)
            end

            if strafeMode == "Orbit" then
                local angle = tick() * strafeSpeed
                local offset = Vector3.new(math.cos(angle) * strafeXOffset, -0.1, math.sin(angle) * strafeXOffset)
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition + offset, targetPosition)
            elseif strafeMode == "Random" then
                local offset = Vector3.new(math.random(-20, 20), math.random(-10, 10), math.random(-20, 20))
                local randomrotation = CFrame.Angles(
                    math.rad(math.random(0, 360)),
                    math.rad(math.random(0, 360)),
                    math.rad(math.random(0, 360))
                )
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition + offset) * randomrotation
            end
        end

        local humanoid = lockedTarget.Character:FindFirstChild("Humanoid")
        if humanoid then
            if not getgenv().lastHealth[lockedTarget.Name] then
                getgenv().lastHealth[lockedTarget.Name] = humanoid.Health
            end
            if humanoid.Health < getgenv().lastHealth[lockedTarget.Name] then
                playHitsound()
            end
            getgenv().lastHealth[lockedTarget.Name] = humanoid.Health
        end

        if TracerEnabled and targetPart then
            tracer.Visible = true
            local camera = workspace.CurrentCamera
            local targetScreenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
            local endScreenPos

            if targetToMouseTracer then
                endScreenPos = UserInputService:GetMouseLocation()
            else
                local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local rootScreenPos, rootOnScreen = camera:WorldToViewportPoint(rootPart.Position)
                    if rootOnScreen then
                        endScreenPos = Vector2.new(rootScreenPos.X, rootScreenPos.Y)
                    end
                end
            end

            if onScreen and endScreenPos then
                tracer.From = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                tracer.To = endScreenPos
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end

        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        local handle = tool and tool:FindFirstChild("Handle")
        if tool and handle and targetPart and not isKO and not isGrabbed then
            if hiddenBulletsEnabled then
                ReplicatedStorage.MainEvent:FireServer(
                    "ShootGun",
                    handle,
                    handle.CFrame.Position - Vector3.new(0, 10, 0),
                    targetPart.Position - Vector3.new(0, 10, 0),
                    targetPart,
                    Vector3.new(0, 0, -1))
            else
                ReplicatedStorage.MainEvent:FireServer(
                    "ShootGun",
                    handle,
                    handle.CFrame.Position,
                    targetPart.Position,
                    targetPart,
                    Vector3.new(0, 0, -1))
            end
        end
    else
        tracer.Visible = false
    end
end)

task.spawn(function()
    while true do
        if stompTargetEnabled and lockedTarget and lockedTarget ~= LocalPlayer then
            local character = lockedTarget.Character
            if character then
                local bodyEffects = character:FindFirstChild("BodyEffects")
                local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local isSDeath = bodyEffects and bodyEffects:FindFirstChild("SDeath") and bodyEffects["SDeath"].Value

                if isKO and not isSDeath then
                    local upperTorso = character:FindFirstChild("UpperTorso")
                    if upperTorso then
                        local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                        if not lastPosition then
                            lastPosition = humanoidRootPart.Position
                        end
                        humanoidRootPart.CFrame = CFrame.new(upperTorso.Position + Vector3.new(0, 3, 0))
                        RunService.RenderStepped:Wait()
                    end
                elseif isSDeath and lastPosition then
                    if killSayEnabled then
                        local message = killSayMessages[math.random(1, #killSayMessages)]
                        game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
                    end
                    local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                    while (humanoidRootPart.Position - lastPosition).Magnitude > 5 do
                        humanoidRootPart.CFrame = CFrame.new(lastPosition)
                        task.wait()
                    end
                    lastPosition = nil
                end
            else
                if lastPosition then
                    local humanoidRootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
                    while (humanoidRootPart.Position - lastPosition).Magnitude > 5 do
                        humanoidRootPart.CFrame = CFrame.new(lastPosition)
                        task.wait()
                    end
                    lastPosition = nil
                end
            end
            ReplicatedStorage.MainEvent:FireServer("Stomp")
        end
        task.wait(0)
    end
end)


local StarterGui = game:GetService("StarterGui")
local RapidFireEnabled = false
local hyperFireEnabled = false
local modifiedTools = {}

local function rapidfire(tool)
    if not tool or not tool:FindFirstChild("GunScript") or modifiedTools[tool] then return end

    for _, v in ipairs(getconnections(tool.Activated)) do
        local funcinfo = debug.getinfo(v.Function)
        for i = 1, funcinfo.nups do
            local c, n = debug.getupvalue(v.Function, i)
            if type(c) == "number" then
                debug.setupvalue(v.Function, i, 0.0000000000001)
            end
        end
    end

    modifiedTools[tool] = true
end

local function onCharacterAdded(character)
    for _, tool in ipairs(character:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
            rapidfire(tool)
        end
    end

    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and child:FindFirstChild("Handle") then
            rapidfire(child)
        end
    end)
end

if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

GunMods:AddToggle("RapidFireToggle", {
    Text = "Rapid Fire",
    Default = false,
    Callback = function(Value)
        RapidFireEnabled = Value
        if Value then
            modifiedTools = {}
            if LocalPlayer.Character then
                onCharacterAdded(LocalPlayer.Character)
            end
        end
    end
})

local function updateHyperFire()
    for _, obj in ipairs(game:GetDescendants()) do
        if obj.Name == "ToleranceCooldown" and obj:IsA("ValueBase") then
            obj.Value = 0 
        end
    end
end

GunMods:AddToggle("HyperFireToggle", {
    Text = "Rapid Fire v2",
    Default = false,
    Callback = function(Value)
        hyperFireEnabled = Value
        updateHyperFire()
    end
})

game.DescendantAdded:Connect(function(obj)
    if obj.Name == "ToleranceCooldown" and obj:IsA("ValueBase") then
        obj.Value = hyperFireEnabled and 0 or 3
    end
end)

RunService.RenderStepped:Connect(function()
    if hyperFireEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
        local character = LocalPlayer.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:FindFirstChild("Ammo") then
                tool:Activate()
            end
        end
    end
end)

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimlock')


    -- Services and Variables
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Camera = workspace.CurrentCamera
    local Workspace = game:GetService("Workspace")
    
    local LocalPlayer = Players.LocalPlayer
    
    local cursorLocked = false
    local targetHead = nil
    local targetPlayer = nil
    local previewHighlight = nil
    local lockedHighlight = nil
    local predictionLevel = 0 -- Default prediction level, can be changed (higher value = more prediction)
    local currentKeybind = Enum.KeyCode.C
    local previewColor = Color3.fromRGB(0, 0, 255) -- Default preview color
    local lockedHighlightColor = Color3.fromRGB(255, 0, 0) -- Default locked highlight color
    local smoothness = 0 -- Default smoothness value
    local highlightsEnabled = false -- Default value for highlights toggle
    
    local ragelock = false  -- Default value for ragelock
    local orbitActive = false  -- Flag for orbit feature
    local orbitSpeed = 10 -- Orbit speed
    local radius = 8 -- Orbit size
    local rotation = CFrame.Angles(0, 0, 0) -- Rotation angles
    
    -- Ensure aimlock state is toggled correctly on each execution
    if _G.aimlock == nil then
        _G.aimlock = false  -- Default value if not previously set
    end
    
    -- Function to check if the player is knocked or grabbed
    local function IsPlayerKnockedOrGrabbed(player)
        local character = player.Character
        if character then
            local bodyEffects = character:FindFirstChild("BodyEffects")
            local grabbingConstraint = character:FindFirstChild("GRABBING_CONSTRAINT")
            if bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value or grabbingConstraint then
                return true
            end
        end
        return false
    end
    
    -- Function to calculate the predicted position based on velocity
    local function GetPredictedPosition(player)
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            local head = character:FindFirstChild("Head")
            if humanoid and head then
                local velocity = humanoid.RootPart.AssemblyLinearVelocity
                return head.Position + velocity * predictionLevel
            end
        end
        return nil
    end
    
    -- Function to find the closest player's head, with prediction
    local function FindClosestPlayerHead()
        local closestPlayer = nil
        local closestDistance = math.huge
        local mousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
    
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                local character = player.Character
                local humanoid = character:FindFirstChild("Humanoid")
    
                if humanoid and humanoid.Health > 0 then
                    if IsPlayerKnockedOrGrabbed(player) then continue end  -- Skip locked/knocked/grabbed players
                    local head = character.Head
                    local predictedHeadPosition = GetPredictedPosition(player) or head.Position
                    local screenPoint = Camera:WorldToScreenPoint(predictedHeadPosition)
                    local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                    local playerDistance = (Camera.CFrame.Position - predictedHeadPosition).Magnitude
    
                    local ray = Ray.new(Camera.CFrame.Position, predictedHeadPosition - Camera.CFrame.Position)
                    local hitPart, hitPosition = Workspace:FindPartOnRay(ray, LocalPlayer.Character)
    
                    -- Lock even through walls for players within 100 studs
                    if playerDistance <= 100 or (not hitPart or hitPart.Parent == character) then
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    
        if closestPlayer then
            return closestPlayer.Character.Head, closestPlayer
        end
        return nil, nil
    end
    
    -- Function to add a preview highlight for the closest player
    local function AddPreviewHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        -- If preview highlight already exists for this player, return early
        if previewHighlight and previewHighlight.Parent == player.Character then
            previewHighlight.FillColor = previewColor
            return
        end
    
        -- Destroy previous preview highlight if it exists
        if previewHighlight then
            previewHighlight:Destroy()
        end
    
        -- Create a new preview highlight for the closest player
        if player and player.Character then
            previewHighlight = Instance.new("Highlight")
            previewHighlight.Parent = player.Character
            previewHighlight.FillTransparency = 0.5
            previewHighlight.FillColor = previewColor
        end
    end
    
    -- Function to add a red highlight to the locked player
    local function AddLockedHighlight(player)
        if not highlightsEnabled then return end -- Skip if highlights are disabled
    
        -- If locked highlight already exists for this player, return early
        if lockedHighlight and lockedHighlight.Parent == player.Character then
            lockedHighlight.FillColor = lockedHighlightColor
            return
        end
    
        -- Destroy previous locked highlight if it exists
        if lockedHighlight then
            lockedHighlight:Destroy()
        end
    
        -- Create a new locked highlight for the locked player
        if player and player.Character then
            lockedHighlight = Instance.new("Highlight")
            lockedHighlight.Parent = player.Character
            lockedHighlight.FillTransparency = 0.5
            lockedHighlight.FillColor = lockedHighlightColor
        end
    end
    
    -- Lock the cursor to the nearest player's head
    local function LockCursorToHead()
        targetHead, targetPlayer = FindClosestPlayerHead()
        if targetHead then
            AddLockedHighlight(targetPlayer)  -- Add highlight to locked player
            if previewHighlight then previewHighlight:Destroy() end  -- Destroy preview highlight if it exists
            UserInputService.MouseIconEnabled = false
        end
    end
    
    -- Unlock the cursor
    local function UnlockCursor()
        UserInputService.MouseIconEnabled = true
        targetHead = nil
        targetPlayer = nil
        if lockedHighlight then lockedHighlight:Destroy() end
    end
    
    -- Function to activate orbiting around the target player
    local function ActivateOrbit(player)
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            targetPlayer = player
        end
    end
    
    -- Function to deactivate orbiting
    local function DeactivateOrbit()
        targetPlayer = nil
    end
    
    -- Function to handle automatic targeting for RageLock
    local function HandleRageLock()
        -- Ensure RageLock only locks onto the target if it's valid
        if ragelock then
            -- Check if targetPlayer is invalid or knocked
            if targetPlayer and IsPlayerKnockedOrGrabbed(targetPlayer) then
                -- If the locked target is knocked or grabbed, unlock and search for the next target
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[RageLock] Target is knocked/grabbed, unlocking and searching for next target.")
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
                return
            end
    
            -- If no valid target is locked, search for a new one
            if not targetPlayer then
                targetHead, targetPlayer = FindClosestPlayerHead()
                if targetPlayer then
                    cursorLocked = true
                    LockCursorToHead()
                    AddLockedHighlight(targetPlayer)  -- Add highlight to new target
                end
            end
        end
    end
    
    -- Orbit update loop (only runs when orbit toggle is true)
    RunService.Stepped:Connect(function(_, dt)
        if orbitActive then
            -- Only update orbit if the toggle is true and the player is locked onto a valid target
            if cursorLocked and targetPlayer then
                -- Only update orbit if the target is locked (Aimlock or RageLock)
                local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHumanoidRootPart then
                    local rot = tick() * orbitSpeed
                    local lpr = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if lpr then
                        -- Orbit calculation (only orbits if locked onto target)
                        lpr.CFrame = CFrame.new(
                            targetHumanoidRootPart.Position + Vector3.new(math.sin(rot) * radius, 0, math.cos(rot) * radius)
                        )
                    end
                end
            end
        end
    
        -- Update loop to continuously follow the locked target for aimlock
        if cursorLocked and _G.aimlock and targetHead then
            -- Handle ragelock to auto lock onto next target if necessary
            if ragelock then
                HandleRageLock()  -- Call the function to handle RageLock auto-targeting
            end
    
            -- Check if the locked player is knocked or grabbed and unlock if necessary
            if IsPlayerKnockedOrGrabbed(targetPlayer) then
                cursorLocked = false
                UnlockCursor()
                DeactivateOrbit()
                print("[Auto Unlock] Target player is knocked or grabbed, unlocking cursor.")
            else
                        -- Proceed with the normal aimlock and orbit
        local predictedHeadPosition = GetPredictedPosition(targetPlayer) or targetHead.Position
        -- Smoothly interpolate the camera's CFrame
        local alpha = 1 - smoothness
        alpha = math.max(alpha, 0.01)  -- Ensure alpha is never 0
        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedHeadPosition), alpha)
            end
        elseif not cursorLocked and _G.aimlock then
            local closestHead, closestPlayer = FindClosestPlayerHead()
            if closestPlayer ~= targetPlayer then
                AddPreviewHighlight(closestPlayer)
            end
        end
    end)
    
    -- Handle key press (C) for locking the cursor
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
            if _G.aimlock then
                cursorLocked = not cursorLocked
                if cursorLocked then
                    LockCursorToHead()
                    if orbitActive then
                        ActivateOrbit(targetPlayer)  -- Activate orbit when locking onto a player and orbiting is enabled
                    end
                else
                    UnlockCursor()
                    DeactivateOrbit()  -- Deactivate orbit when unlocking
                end
            end
        end
    end)
    
    -- UI Controls for setting various values like keybinds and highlight colors
    LeftGroupBox:AddToggle('Aimlock', {
        Text = 'Aimlock',
        Default = false,
        Tooltip = 'Locks your aim onto players heads',
        Callback = function(Value)
            _G.aimlock = Value
            print('[cb] Aimlock changed to:', Value)
            if _G.aimlock then
                cursorLocked = false  -- Ensure cursor is not locked when aimlock is turned on
            end
        end
    })
    
    LeftGroupBox:AddToggle('RageLock', {
        Text = 'RageLock',
        Default = false,
        Tooltip = 'Automatically locks onto the next available player',
        Callback = function(Value)
            ragelock = Value
            print('[cb] RageLock changed to:', Value)
        end
    })
    
    LeftGroupBox:AddToggle('OrbitFeature', {
        Text = 'Orbit Around Target',
        Default = false,
        Tooltip = 'Toggle to start orbiting around the player you lock onto.',
        Callback = function(value)
            orbitActive = value  -- Directly set orbitActive based on toggle state
            if orbitActive and cursorLocked then
                ActivateOrbit(targetPlayer) -- Activate orbit only if locked onto a player
            else
                DeactivateOrbit()  -- Deactivate orbit when the toggle is off
            end
        end
    })
    
    -- Add Toggle for Highlights
    LeftGroupBox:AddToggle('HighlightsToggle', {
        Text = 'Highlights',
        Default = highlightsEnabled,
        Tooltip = 'Toggle to enable or disable highlights',
        Callback = function(Value)
            highlightsEnabled = Value
            print('[cb] Highlights toggled:', Value)
            if not Value then
                -- Destroy highlights if they exist
                if previewHighlight then
                    previewHighlight:Destroy()
                    previewHighlight = nil
                end
                if lockedHighlight then
                    lockedHighlight:Destroy()
                    lockedHighlight = nil
                end
            end
        end
    })
    
    LeftGroupBox:AddLabel('Keybind'):AddKeyPicker('KeyPicker', {
        Default = 'C',
        SyncToggleState = false,
        Mode = 'Toggle',
        Text = 'Aimlock',
        ChangedCallback = function(New)
            print('[cb] Keybind changed!', New)
            currentKeybind = New
        end
    })
    
    LeftGroupBox:AddLabel('Preview Color'):AddColorPicker('PreviewColorPicker', {
        Default = previewColor,
        Title = 'Preview Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Preview Color changed!', Value)
            previewColor = Value
            if previewHighlight then
                previewHighlight.FillColor = Value
            end
        end
    })
    
    LeftGroupBox:AddLabel('Locked Highlight Color'):AddColorPicker('LockedColorPicker', {
        Default = lockedHighlightColor,
        Title = 'Locked Player Highlight Color',
        Transparency = 0,
        Callback = function(Value)
            print('[cb] Locked Highlight Color changed!', Value)
            lockedHighlightColor = Value
            if lockedHighlight then
                lockedHighlight.FillColor = Value
            end
        end
    })
    
    -- Add Smoothness Slider
    LeftGroupBox:AddSlider('SmoothnessSlider', {
        Text = 'Smoothness',
        Default = smoothness,
        Min = 0,
        Max = 1,
        Rounding = 2,
        Callback = function(Value)
            print('[cb] Smoothness changed!', Value)
            smoothness = Value
        end
    })
    
    LeftGroupBox:AddSlider('Orbit Speed', {
        Text = 'Orbit Speed',
        Default = orbitSpeed,
        Min = 0,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Orbit Speed changed!', Value)
            orbitSpeed = Value
        end
    })
    
    LeftGroupBox:AddSlider('PredictionSlider', {
        Text = 'Prediction',
        Default = predictionLevel,
        Min = 0,
        Max = 1,
        Rounding = 1,
        Callback = function(Value)
            print('[cb] Prediction changed!', Value)
            predictionLevel = Value
        end
    })

getgenv().range = 250

getgenv().whitelist = {}


getgenv().tracer = Instance.new("Part")
getgenv().tracer.Size = Vector3.new(0.2, 0.2, 0.2)
getgenv().tracer.Material = Enum.Material.Neon
getgenv().tracer.Color = Color3.new(1, 0, 0)
getgenv().tracer.Transparency = 1
getgenv().tracer.Anchored = true
getgenv().tracer.CanCollide = false
getgenv().tracer.Parent = workspace

getgenv().enabled = false
getgenv().active = false
getgenv().visualizeEnabled = false
getgenv().silentEnabled = false
getgenv().lastHealth = {}

KillAura:AddToggle('MainToggle', {
    Text = 'Kill Aura',
    Default = false,
    Callback = function(state)
        getgenv().enabled = state
        if not state then
            getgenv().active = false
            getgenv().tracer.Transparency = 1
        end
    end
}):AddKeyPicker('Keybind', {
    Default = 'K',
    Text = 'kill aura',
    Mode = 'Toggle',
    Callback = function(state)
        if not getgenv().enabled or UserInputService:GetFocusedTextBox() then return end
        getgenv().active = state
    end
})

KillAura:AddSlider("Range", {
    Text = "Range",
    Default = 250,
    Min = 10,
    Max = 250,
    Rounding = 1,
    Callback = function(value)
        getgenv().range = value
    end
})

KillAura:AddToggle('Visualizer', {
    Text = 'Visualize',
    Default = false,
    Callback = function(state)
        getgenv().visualizeEnabled = state
    end
}):AddColorPicker('VisualizerColor', {
    Text = 'Visualizer Color',
    Default = Color3.new(1, 0, 0),
    Callback = function(value)
        getgenv().tracer.Color = value
    end
})

KillAura:AddToggle('Silent', {
    Text = 'Silent',
    Default = false,
    Callback = function(state)
        getgenv().silentEnabled = state
    end
})

KillAura:AddInput('wlb', {
    Default = '',
    Numeric = false,
    Finished = false,
    Text = 'Add/Remove Player',
    Tooltip = 'Type a name or display name to add/remove from whitelist',
    Placeholder = 'Player Name',
    Callback = function(input)
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Name == input or player.DisplayName == input then
                if getgenv().whitelist[player.Name] then
                    getgenv().whitelist[player.Name] = nil
                    Library:Notify(player.Name .. " removed from whitelist.", 2)
                else
                    getgenv().whitelist[player.Name] = true
                    Library:Notify(player.Name .. " added to whitelist.", 2)
                end
                return
            end
        end
        Library:Notify("Player not found.", 2)
    end,
    Autocomplete = function(input)
        local suggestions = {}
        for _, player in pairs(game.Players:GetPlayers()) do
            if string.find(string.lower(player.Name), string.lower(input)) or string.find(string.lower(player.DisplayName), string.lower(input)) then
                table.insert(suggestions, player.Name .. " (" .. player.DisplayName .. ")")
            end
        end
        return suggestions
    end
})



task.spawn(function()
    while true do
        if getgenv().active and getgenv().enabled and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle") then
            if workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name) and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name):FindFirstChild("BodyEffects") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name).BodyEffects:FindFirstChild("K.O") and workspace.Players:FindFirstChild(game.Players.LocalPlayer.Name).BodyEffects["K.O"].Value then
                task.wait()
            else
                local closest = math.huge
                target = nil

                for _, player in pairs(game.Players:GetPlayers()) do
                    if player ~= game.Players.LocalPlayer and not getgenv().whitelist[player.Name] and player.Character and player.Character:FindFirstChild("Head") and not player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
                        if workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild(player.Name) and workspace.Players:FindFirstChild(player.Name):FindFirstChild("BodyEffects") and workspace.Players:FindFirstChild(player.Name).BodyEffects:FindFirstChild("K.O") and not workspace.Players:FindFirstChild(player.Name).BodyEffects["K.O"].Value then
                            local dist = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - player.Character.Head.Position).Magnitude
                            if dist < closest and dist <= getgenv().range then
                                closest = dist
                                target = player
                            end
                        end
                    end
                end

                if target and target.Character and target.Character:FindFirstChild("Head") then
                    if getgenv().visualizeEnabled then
                        getgenv().tracer.Transparency = 0
                        getgenv().tracer.Size = Vector3.new(0.2, 0.2, (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - target.Character.Head.Position).Magnitude)
                        getgenv().tracer.CFrame = CFrame.lookAt(game.Players.LocalPlayer.Character.HumanoidRootPart.Position, target.Character.Head.Position) * CFrame.new(0, 0, -getgenv().tracer.Size.Z / 2)
                    else
                        getgenv().tracer.Transparency = 1
                    end

                    local humanoid = target.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        if not getgenv().lastHealth[target.Name] then
                            getgenv().lastHealth[target.Name] = humanoid.Health
                        end
                        if humanoid.Health < getgenv().lastHealth[target.Name] then
                            playHitsound()
                        end
                        getgenv().lastHealth[target.Name] = humanoid.Health
                    end

                    if getgenv().silentEnabled then
                        game.ReplicatedStorage.MainEvent:FireServer(
                            "ShootGun",
                            game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle"),
                            game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").CFrame.Position - Vector3.new(0, 12, 0),
                            target.Character.Head.Position - Vector3.new(0, 12, 0),
                            target.Character.Head,
                            Vector3.new(0, 0, -1)
                    )
                    else
                        game.ReplicatedStorage.MainEvent:FireServer("ShootGun", game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle"), game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").CFrame.Position, target.Character.Head.Position, target.Character.Head, Vector3.new(0, 0, -1))
                    end
                else
                    getgenv().tracer.Transparency = 1
                end
            end
        else
            getgenv().tracer.Transparency = 1
        end
        task.wait()
    end
end)
